searchState.loadedDescShard("glsl_lang_lexer", 0, "A list of comments indexed by their position\nType of lexical analysis error\nThe identifier is a function declaration name\nDefault GLSL type table policy: only struct declarations …\nLanguage lexer error definition\nContext in which an identifier is seen for the first time\nType of the input for this lexer\nType of the iterator returned by this lexer\nGLSL language lexer\nGLSL language lexer iterator\nParsing context\nParsing context data\nParsing options\nA policy to dictate which identifiers should be seen as …\nAllow Rust quoting identifiers (<code>#(ident)</code>) in the source\nList of parsed comments (or <code>None</code> to disable comment …\nParsing data\nDefault GLSL version number to parse source as\nList of known type names\nInstantiate the lexer\nReturn <code>true</code> if the given identifier (in its context) …\nRun the lexer\nUnique source identifier for token positions\n<code>true</code> if the GLSL target should be Vulkan instead of OpenGL\nglsl-lang-pp/full based lexer\nA list of comments indexed by their position\nThe identifier is a function declaration name\nDefault GLSL type table policy: only struct declarations …\nContext in which an identifier is seen for the first time\nParsing context\nParsing context data\nParsing options\nA policy to dictate which identifiers should be seen as …\nAdd a new comment to the parsed comments list\nAdd a new comment to the parsed comments list\nRegister <code>name</code> as a new type name\nRegister <code>name</code> as a new type name\nAllow Rust quoting identifiers (<code>#(ident)</code>) in the source\nClone the parsing data and return the cloned context\nGet the list of comments stored in this parse context\nList of parsed comments (or <code>None</code> to disable comment …\nObtain a reference to the context’s data\nParsing data\nObtain an exclusive reference to the context’s data\nDefault GLSL version number to parse source as\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn <code>true</code> if this parsing context supports comments\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsume this ParseContext and return its data. Will fail …\nReturn <code>true</code> if the given name is a type name\nReturn <code>true</code> if the given name is a type name\nList of known type names\nCreate new parsing options using default values\nCreate a new parsing context from this options object\nCreate a new ParseContextData object\nUpdate the context data with a new identifier in a given …\nUpdate the context data with a new identifier in a given …\nCreate a new parsing context from this options object, …\nCreate a new parsing context from this options object, …\nCreate a new parsing context from this options object and …\nCreate a new parsing context from this options object, …\nLeave the current nesting level\nLeave the current nesting level\nReturn <code>true</code> if the given identifier (in its context) …\nEnter a new nesting level for declarations\nEnter a new nesting level for declarations\nUnique source identifier for token positions\n<code>true</code> if the GLSL target should be Vulkan instead of OpenGL\nCreate a new ParseContextData object with comments parsing …\nCreate a new ParseContextData object with comments parsing …\nCreate a new parse context cloning the given one’s data, …\nCreate a new ParseContextData object with the given type …\nReturn this token’s inner text as a string slice\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturn <code>true</code> if this token is a preprocessor token\ni/o error\nLexical analysis error\nPreprocessor error\nInvalid token in lexical analysis\nReturns the argument unchanged.\nFilesystem based glsl-lang-pp preprocessing lexer\nCalls <code>U::from(self)</code>.\nMemory based glsl-lang-pp preprocessing lexer\nType of invalid token error\nLocation of the error\nContains the error value\nContains the success value\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA preprocessor parsed file ready for lexing\nglsl-lang-pp filesystem lexer\nglsl-lang-pp filesystem lexer iterator\nglsl-lang-pp preprocessor extensions\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nOpen the given file for lexing\nOpen the given source block for lexing\nSet the extension registry to use for this file\nSet the default processor state for processing this file\nglsl-lang-pp memory lexer\nglsl-lang-pp memory lexer iterator\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")