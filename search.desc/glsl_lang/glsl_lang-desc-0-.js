searchState.loadedDescShard("glsl_lang", 0, "<code>glsl-lang</code> is a crate implementing a LALR parser for the …\nGLSL abstract syntax tree and grammar.\nParsing utilities and entry points\nGLSL transpilers – i.e. going from GLSL to anything else.\nAST visitors (i.e. on-the-fly mutation at different places …\nSpecified with angle brackets.\n<code>+</code> unary operator\n<code>+</code> binary operator\n<code>+=</code> assignment operator\nAll extensions you could ever imagine in your whole …\n<code>&amp;&amp;</code> binary operator\n<code>&amp;=</code> assignment operator\nType alias for <code>Node&lt;ArraySpecifierData&gt;</code>.\nDimensionality of an array.\nType alias for <code>Node&lt;ArraySpecifierDimensionData&gt;</code>.\nOne array specifier dimension.\nType alias for <code>Node&lt;ArrayedIdentifierData&gt;</code>.\nAn identifier with an optional array specifier.\nAn assignment is also an expression. Gathers an expression …\nA variable declaration used as a condition\nType alias for <code>Node&lt;AssignmentOpData&gt;</code>.\nAll possible operators for assigning expressions.\n<code>atomic_uint</code> type specifier\n<code>attribute</code> storage qualifier\n<code>bvec2</code> type specifier\n<code>bvec3</code> type specifier\n<code>bvec4</code> type specifier\nA binary expression, gathering two expressions and a …\nType alias for <code>Node&lt;BinaryOpData&gt;</code>.\nAll binary operators that exist in GLSL.\n<code>&amp;</code> binary operator\n<code>|</code> binary operator\n<code>^</code> binary operator\nType alias for <code>Node&lt;BlockData&gt;</code>.\nBlock declaration\nA general purpose block, containing fields and possibly a …\n<code>bool</code> type specifier\nBoolean constant expression.\nAdd an array specifier to an expression.\n<code>break</code> jump statement\n<code>buffer</code> storage qualifier\n<code>case:</code> case label\nType alias for <code>Node&lt;CaseLabelData&gt;</code>.\nSwitch statement case label\nCase label statement.\n<code>centroid</code> storage qualifier\n<code>coherent</code> storage qualifier\nAn expression that contains several, separated with comma.\nType alias for <code>Node&lt;CommentData&gt;</code>.\nA comment\n<code>compatibility</code> version profile\n<code>~</code> unary operator\nStatement block\nType alias for <code>Node&lt;CompoundStatementData&gt;</code>.\nCompound statement (with no new scope).\nType alias for <code>Node&lt;ConditionData&gt;</code>.\nCondition.\n<code>const</code> storage qualifier\n<code>continue</code> jump statement\n<code>core</code> version profile\n<code>dmat2</code> type specifier\n<code>dmat2x2</code> type specifier\n<code>dmat2x3</code> type specifier\n<code>dmat2x4</code> type specifier\n<code>dmat3</code> type specifier\n<code>dmat3x2</code> type specifier\n<code>dmat3x3</code> type specifier\n<code>dmat3x4</code> type specifier\n<code>dmat4</code> type specifier\n<code>dmat4x2</code> type specifier\n<code>dmat4x3</code> type specifier\n<code>dmat4x4</code> type specifier\n<code>dvec2</code> type specifier\n<code>dvec3</code> type specifier\n<code>dvec4</code> type specifier\n<code>--</code> unary operator\nType alias for <code>Node&lt;DeclarationData&gt;</code>.\nDeclaration\nDeclaration\nVariable declaration\nA declaration.\n<code>default:</code> case label\n<code>#define</code> preprocessor directive\n<code>disable</code> preprocessor extension behavior\n<code>discard</code> jump statement\n<code>/</code> binary operator\n<code>/=</code> assignment operator\n<code>do</code> iteration statement\nAn expression associated with a field selection (struct).\n<code>double</code> type specifier\nDouble precision floating expression.\nThe first argument is the body of the if, the rest is the …\n<code>#else</code> preprocessor directive\n<code>#elseif</code> preprocessor directive\n<code>enable</code> preprocessor extension behavior\n<code>#endif</code> preprocessor directive\n<code>==</code> binary operator\n<code>=</code> assignment operator\n<code>#error</code> preprocessor directive\n<code>es</code> version profile\n<code>[expr]</code> dimension\nType alias for <code>Node&lt;ExprData&gt;</code>.\nExpression used for the function name\nAn expression\nThe most general form of an expression.\nType alias for <code>Node&lt;ExprStatementData&gt;</code>.\nExpression statement.\nExpression statement\nExpression\n<code>#extension</code> preprocessor directive\nType alias for <code>Node&lt;ExternalDeclarationData&gt;</code>.\nExternal declaration.\nUnique file identifier\n<code>flat</code> interpolation qualifier\n<code>float</code> type specifier\nSingle precision floating expression.\n<code>for</code> iteration statement\nType alias for <code>Node&lt;ForInitStatementData&gt;</code>.\nFor init statement.\nType alias for <code>Node&lt;ForRestStatementData&gt;</code>.\nFor init statement.\nType alias for <code>Node&lt;FullySpecifiedTypeData&gt;</code>.\nFully specified type.\nA functional call. It has a function identifier and a list …\nType alias for <code>Node&lt;FunIdentifierData&gt;</code>.\nFunction identifier.\nType alias for <code>Node&lt;FunctionDefinitionData&gt;</code>.\nFunction definition\nFunction definition.\nA preprocessor function definition\nType alias for <code>Node&lt;FunctionParameterDeclarationData&gt;</code>.\nFunction parameter declaration.\nType alias for <code>Node&lt;FunctionParameterDeclaratorData&gt;</code>.\nFunction parameter declarator.\nType alias for <code>Node&lt;FunctionPrototypeData&gt;</code>.\nFunction prototype declaration\nFunction prototype.\n<code>&gt;</code> binary operator\n<code>&gt;=</code> binary operator\n<code>high</code> precision qualifier\n<code>iimage1D</code> type specifier\n<code>iimage1DArray</code> type specifier\n<code>iimage2D</code> type specifier\n<code>iimage2DArray</code> type specifier\n<code>iimage2DMS</code> type specifier\n<code>iimage2DMSArray</code> type specifier\n<code>iimage2DRect</code> type specifier\n<code>iimage3D</code> type specifier\n<code>iimageBuffer</code> type specifier\n<code>iimageCube</code> type specifier\n<code>iimageCubeArray</code> type specifier\n<code>isampler1D</code> type specifier\n<code>isampler1DArray</code> type specifier\n<code>isampler2D</code> type specifier\n<code>isampler2DArray</code> type specifier\n<code>isampler2DMS</code> type specifier\n<code>isampler2DMSArray</code> type specifier\n<code>isampler2DRect</code> type specifier\n<code>isampler3D</code> type specifier\n<code>isamplerBuffer</code> type specifier\n<code>isamplerCube</code> type specifier\n<code>isamplerCubeArray</code> type specifier\n<code>isubpassInput</code> type specifier\n<code>isubpassInputMs</code> type specifier\n<code>itexture1D</code> type specifier\n<code>itexture1DArray</code> type specifier\n<code>itexture2D</code> type specifier\n<code>itexture2DArray</code> type specifier\n<code>itexture2DMs</code> type specifier\n<code>itexture2DMsArray</code> type specifier\n<code>itexture2DRect</code> type specifier\n<code>itexture3D</code> type specifier\n<code>itextureBuffer</code> type specifier\n<code>itextureCube</code> type specifier\n<code>itextureCubeArray</code> type specifier\n<code>ivec2</code> type specifier\n<code>ivec3</code> type specifier\n<code>ivec4</code> type specifier\nType alias for <code>Node&lt;IdentifierData&gt;</code>.\nAn <code>ident = expr</code> layout qualifier\nA generic identifier.\n<code>#if</code> preprocessor directive\n<code>#ifdef</code> preprocessor directive\n<code>#ifndef</code> preprocessor directive\n<code>image1D</code> type specifier\n<code>image1DArray</code> type specifier\n<code>image2D</code> type specifier\n<code>image2DArray</code> type specifier\n<code>image2DMS</code> type specifier\n<code>image2DMSArray</code> type specifier\n<code>image2DRect</code> type specifier\n<code>image3D</code> type specifier\n<code>imageBuffer</code> type specifier\n<code>imageCube</code> type specifier\n<code>imageCubeArray</code> type specifier\n<code>in</code> storage qualifier\n<code>inout</code> storage qualifier\n<code>++</code> unary operator\n<code>#include</code> preprocessor directive\nType alias for <code>Node&lt;InitDeclaratorListData&gt;</code>.\nList of declarators and initializers\nInit declarator list.\nType alias for <code>Node&lt;InitializerData&gt;</code>.\nInitializer.\n<code>int</code> type specifier\nIntegral constant expression.\nInterpolation qualifier\nType alias for <code>Node&lt;InterpolationQualifierData&gt;</code>.\nInterpolation qualifier.\n<code>invariant</code> qualifier\nInvariant declaration\nIteration statement\nType alias for <code>Node&lt;IterationStatementData&gt;</code>.\nIteration statement.\nJump statement\nType alias for <code>Node&lt;JumpStatementData&gt;</code>.\nJump statement.\n<code>&lt;&lt;</code> binary operator\n<code>&lt;&lt;=</code> assignment operator\nLayout qualifier\nType alias for <code>Node&lt;LayoutQualifierData&gt;</code>.\nLayout qualifier.\nType alias for <code>Node&lt;LayoutQualifierSpecData&gt;</code>.\nLayout qualifier spec.\n<code>#line</code> preprocessor directive\nMultiple initializer\n<code>low</code> precision qualifier\n<code>&lt;</code> binary operator\n<code>&lt;=</code> binary operator\n<code>mat2</code> type specifier\n<code>mat2x2</code> type specifier\n<code>mat2x3</code> type specifier\n<code>mat2x4</code> type specifier\n<code>mat3</code> type specifier\n<code>mat3x2</code> type specifier\n<code>mat3x3</code> type specifier\n<code>mat3x4</code> type specifier\n<code>mat4</code> type specifier\n<code>mat4x2</code> type specifier\n<code>mat4x3</code> type specifier\n<code>mat4x4</code> type specifier\n<code>medium</code> precision qualifier\n<code>-</code> unary operator\n<code>%</code> binary operator\n<code>%=</code> assignment operator\n<code>*</code> binary operator\n<code>*</code> assignment operator\nMulti-line comment\nNamed parameter\n<code>noperspective</code> interpolation qualifier\nA syntax node with span information\nTrait for AST node contents.\nDerives an implementation of <code>NodeContentDisplay</code> for the …\nTrait for displaying a syntax node\nSpan information for a node, constructed from a pair of …\n<code>!=</code> binary operator\n<code>!</code> unary operator\nA preprocessor definition\n<code>||</code> binary operator\n<code>|=</code> assignment operator\n<code>out</code> storage qualifier\n<code>patch</code> storage qualifier\nType alias for <code>Node&lt;PathData&gt;</code>.\nA path literal.\nPost-decrementation of an expression.\nPost-incrementation of an expression.\n<code>#pragma</code> preprocessor directive\n<code>precise</code> qualifier\nPrecision qualifier\nPrecision declaration\nType alias for <code>Node&lt;PrecisionQualifierData&gt;</code>.\nPrecision qualifier.\nType alias for <code>Node&lt;PreprocessorData&gt;</code>.\nPreprocessor directive\nSome basic preprocessor directives.\nType alias for <code>Node&lt;PreprocessorDefineData&gt;</code>.\nA #define preprocessor directive.\nType alias for <code>Node&lt;PreprocessorElseIfData&gt;</code>.\nAn #else preprocessor directive.\nType alias for <code>Node&lt;PreprocessorErrorData&gt;</code>.\nAn #error preprocessor directive.\nType alias for <code>Node&lt;PreprocessorExtensionData&gt;</code>.\nType alias for <code>Node&lt;PreprocessorExtensionBehaviorData&gt;</code>.\nAn #extension behavior annotation.\nAn #extension preprocessor directive.\nType alias for <code>Node&lt;PreprocessorExtensionNameData&gt;</code>.\nAn #extension name annotation.\nType alias for <code>Node&lt;PreprocessorIfData&gt;</code>.\nAn #if preprocessor directive.\nType alias for <code>Node&lt;PreprocessorIfDefData&gt;</code>.\nAn #ifdef preprocessor directive.\nType alias for <code>Node&lt;PreprocessorIfNDefData&gt;</code>.\nA #ifndef preprocessor directive.\nType alias for <code>Node&lt;PreprocessorIncludeData&gt;</code>.\nAn #include name annotation.\nType alias for <code>Node&lt;PreprocessorLineData&gt;</code>.\nA #line preprocessor directive.\nType alias for <code>Node&lt;PreprocessorPragmaData&gt;</code>.\nA #pragma preprocessor directive. Holds compiler-specific …\nType alias for <code>Node&lt;PreprocessorUndefData&gt;</code>.\nA #undef preprocessor directive.\nType alias for <code>Node&lt;PreprocessorVersionData&gt;</code>.\nA #version preprocessor directive.\nType alias for <code>Node&lt;PreprocessorVersionProfileData&gt;</code>.\nA #version profile annotation.\n<code>&gt;&gt;</code> binary operator\n<code>&gt;&gt;=</code> assignment operator\n<code>readonly</code> storage qualifier\nSpecified with double quotes.\n<code>require</code> preprocessor extension behavior\n<code>restrict</code> storage qualifier\n<code>return</code> jump statement\n<code>sample</code> storage qualifier\n<code>sampler</code> type specifier\n<code>sampler1D</code> type specifier\n<code>sampler1DArray</code> type specifier\n<code>sampler1DArrayShadow</code> type specifier\n<code>sampler1DShadow</code> type specifier\n<code>sampler2D</code> type specifier\n<code>sampler2DArray</code> type specifier\n<code>sampler2DArrayShadow</code> type specifier\n<code>sampler2DMS</code> type specifier\n<code>sampler2DMSArray</code> type specifier\n<code>sampler2DRect</code> type specifier\n<code>sampler2DRectShadow</code> type specifier\n<code>sampler2DShadow</code> type specifier\n<code>sampler3D</code> type specifier\n<code>samplerBuffer</code> type specifier\n<code>samplerCube</code> type specifier\n<code>samplerCubeArray</code> type specifier\n<code>samplerCubeArrayShadow</code> type specifier\n<code>samplerCubeShadow</code> type specifier\n<code>samplerShadow</code> type specifier\n<code>if/...</code> statement\nType alias for <code>Node&lt;SelectionRestStatementData&gt;</code>.\nSelection rest statement.\nType alias for <code>Node&lt;SelectionStatementData&gt;</code>.\nSelection statement.\n<code>shared</code> storage qualifier\n<code>shared</code> layout qualifier\nSimple initializer\nSingle-line comment\nType alias for <code>Node&lt;SingleDeclarationData&gt;</code>.\nSingle declaration.\nType alias for <code>Node&lt;SingleDeclarationNoTypeData&gt;</code>.\nA single declaration with implicit, already-defined type.\nA <code>SmolStr</code> is a string type that has the following …\n<code>smooth</code> interpolation qualifier\nA specific extension.\nType alias for <code>Node&lt;StatementData&gt;</code>.\nBody of the if.\nStatement.\nStorage qualifier\nType alias for <code>Node&lt;StorageQualifierData&gt;</code>.\nStorage qualifier.\n<code>struct</code> type specifier\nType alias for <code>Node&lt;StructFieldSpecifierData&gt;</code>.\nStruct field specifier. Used to add fields to struct …\nType alias for <code>Node&lt;StructSpecifierData&gt;</code>.\nStruct specifier. Used to create new, user-defined types.\n<code>-</code> binary operator\n<code>-=</code> assignment operator\n<code>subpassInput</code> type specifier\n<code>subpassInputMs</code> type specifier\n<code>subroutine</code> storage qualifier\n<code>switch</code> statement\nType alias for <code>Node&lt;SwitchStatementData&gt;</code>.\nSwitch statement.\nA ternary conditional expression, gathering three …\nA range in text, represented as a pair of <code>TextSize</code>.\nA measure of text length. Also, equivalently, an index …\n<code>texture1D</code> type specifier\n<code>texture1DArray</code> type specifier\n<code>texture2D</code> type specifier\n<code>texture2DArray</code> type specifier\n<code>texture2DMs</code> type specifier\n<code>texture2DMsArray</code> type specifier\n<code>texture2DRect</code> type specifier\n<code>texture3D</code> type specifier\n<code>textureBuffer</code> type specifier\n<code>textureCube</code> type specifier\n<code>textureCubeArray</code> type specifier\nStarting rule.\nType alias for <code>Node&lt;TypeNameData&gt;</code>.\nRaw type name\nAny type name.\nType-only declaration\nType alias for <code>Node&lt;TypeQualifierData&gt;</code>.\nType qualifier.\nType alias for <code>Node&lt;TypeQualifierSpecData&gt;</code>.\nType qualifier spec.\nType alias for <code>Node&lt;TypeSpecifierData&gt;</code>.\nType name used for the function name (as a constructor)\nType specifier.\nType alias for <code>Node&lt;TypeSpecifierNonArrayData&gt;</code>.\nType specifier (non-array).\n<code>uimage1D</code> type specifier\n<code>uimage1DArray</code> type specifier\n<code>uimage2D</code> type specifier\n<code>uimage2DArray</code> type specifier\n<code>uimage2DMS</code> type specifier\n<code>uimage2DMSArray</code> type specifier\n<code>uimage2DRect</code> type specifier\n<code>uimage3D</code> type specifier\n<code>uimageBuffer</code> type specifier\n<code>uimageCube</code> type specifier\n<code>uimageCubeArray</code> type specifier\n<code>uint</code> type specifier\nUnsigned integral constant expression.\n<code>usampler1D</code> type specifier\n<code>usampler1DArray</code> type specifier\n<code>usampler2D</code> type specifier\n<code>usampler2DArray</code> type specifier\n<code>usampler2DMS</code> type specifier\n<code>usampler2DMSArray</code> type specifier\n<code>usampler2DRect</code> type specifier\n<code>usampler3D</code> type specifier\n<code>usamplerBuffer</code> type specifier\n<code>usamplerCube</code> type specifier\n<code>usamplerCubeArray</code> type specifier\n<code>usubpassInput</code> type specifier\n<code>usubpassInputMs</code> type specifier\n<code>uvec2</code> type specifier\n<code>uvec3</code> type specifier\n<code>uvec4</code> type specifier\nA unary expression, gathering a single expression and a …\nType alias for <code>Node&lt;UnaryOpData&gt;</code>.\nAll unary operators that exist in GLSL.\n<code>#undef</code> preprocessor directive\n<code>uniform</code> storage qualifier\nUnnamed parameter\n<code>[]</code> dimension\nA variable expression, using an identifier.\n<code>varying</code> storage qualifier\n<code>vec2</code> type specifier\n<code>vec3</code> type specifier\n<code>vec4</code> type specifier\n<code>#version</code> preprocessor directive\n<code>void</code> type specifier\n<code>volatile</code> storage qualifier\n<code>warn</code> preprocessor extension behavior\n<code>while</code> iteration statement\n<code>writeonly</code> storage qualifier\n<code>^^</code> binary operator\n<code>^=</code> assignment operator\nAttached array specification\nArray part of the specifier\nArray specification\nTry to parse this function identifier as a raw identifier\nTry to parse this function identifier as a mutable raw …\nParses this identifier as a glsl-lang-quote Rust identifier\nTry to parse this function identifier as a <code>glsl-lang-quote</code> …\nTry to parse this function identifier as a <code>glsl-lang-quote</code> …\nReturns a <code>&amp;str</code> slice of this <code>SmolStr</code>.\nReturns this identifier as a string slice\nReturn this type name as a string slice\nCreate a new <code>TextRange</code> with the given <code>offset</code> and <code>len</code> (…\nBehavior for the extension\nBody of the switch statement\nCreate a new file identifier for a built-in string\nAdd an offset to this range.\nChecked addition. Returns <code>None</code> if overflow occurred.\nSubtract an offset from this range.\nChecked subtraction. Returns <code>None</code> if overflow occurred.\nRaw pragma text\nCondition to evaluate\nLoop condition\nCondition expression\nCondition expression\nCheck if this range contains an offset.\nCheck if this range contains an offset.\nCheck if this range completely contains another range.\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nContents of this syntax node\nExtends the range to cover <code>other</code> as well.\nExtends the range to cover <code>other</code> offsets as well.\nDeclare a new variable.\nList of all the dimensions – possibly unsized or …\nObtain a display wrapper for the current node\nDisplay the node’s children\nDisplay extra information for the node\nCreate a zero-length range at the specified offset (…\nEnding position of the node\nThe end point of this range.\nReturn the end of this span as a LexerPosition\nField specifications\nDeclared fields\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new node span from two lexer positions\nFirst declaration\nExpression to evaluate and switch on\nCreate a function identifier from an identifier\nRaw identifier\nParameter name\nDeclared identifier\nIdentifier to test\nIdentifier to test\nAssociated identifiers\nList of declared identifiers for this field\nList of layout qualifiers\nInitializer expression\nInitializer expression\nThe range covered by both ranges, if it exists. If the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn the wrapped syntax node, discarding the span …\nConvert the contents into a node\nReturns <code>true</code> if <code>self</code> has a length of zero bytes.\nCheck if this range is empty.\nReturn true if this range is empty\nReturns <code>true</code> if <code>self</code> is heap-allocated.\ntrue if this comment is a multi-line comment\ntrue if this comment is a single-line comment\nReturns the length of <code>self</code> in bytes.\nThe size of this range.\nReturn the length of this span\nLine index\nMap this content of this node into a new node\nMap this content of this node into a new node with the …\nError message\nName of the syntax node’s type\nStructure name\nBlock name\nFunction name\nDeclared identifier\nIdentifier to undefine\nName of the target extension\nConstructs a <code>SmolStr</code> from a <code>str</code>, heap-allocating if …\nCreates a new <code>TextRange</code> with the given <code>start</code> and <code>end</code> (…\nCreates a new instance of <code>TextSize</code> from a raw <code>u32</code>.\nCreate a new file identifier\nCreate a new syntax node with span information\nCreate a new node span\nCreate a new ArrayedIdentifier from a raw identifier and a …\nCreate a new FullySpecifiedType from a …\nReturn a 0-length span located at the end of the given …\nConstructs an inline variant of <code>SmolStr</code>.\nReturn a 0-length span located at the start of the given …\nConstructs a <code>SmolStr</code> from a statically allocated string.\nGet the number behind this id, regardless of its type\nThe text size of some primitive text-like object.\nRelative order of the two ranges (overlapping ranges are …\nFunction parameters\nInclude path\nLoop increment operation\nVersion profile\nFunction prototype\nType qualifiers for the field\nOptional type qualifier\nBlock type qualifier\nList of type qualifiers\nReturn the span range\nRest of the selection statement\nSource id of the node\nReturn the source identifier for this node span\nSource index\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nSpan in the input this node was parsed from\nAdd span information to a syntax node\nStarting position of the node\nThe start point of this range.\nReturn the start of this span as a LexerPosition\nFunction body\nList of statements\nFollowing declarations\nGet the comment’s text, regardless of its type\nType name portion of the specifier\nType of the field\nType specifier\nReturn type\nParameter type\nDeclaration type\nCreate a range up to the given end (<code>..end</code>).\nConstruct an <code>Expr::Variable(name)</code> from an identifier <code>name</code>\nVersion number\nList of arguments for the function\nIdentifier for the definition\nIdentifier for the definition\nAssociated value\nAssociated value\nDefault lexer to use for parsing sources\nGLSL parsing with the default lexer\nContains the error value\nPart of the syntax tree that can be extracted from a …\nGLSL language parsing capability\nTrait for creating parse builders from lexer inputs\nAST node returned by this parser\nGLSL language parser\nType of the lexer associated with this input\nContains the success value\nA parsable is something we can parse either directly, or …\nGLSL language parsing functions\nBuilder structure for a parsing operation\nParsing context\nParsing context data\nErrors returned by the parsing operation\nParsing options\nResult of a parsing operation\nType of the parser to create\nAdd a new comment to the parsed comments list\nAdd a new comment to the parsed comments list\nRegister <code>name</code> as a new type name\nRegister <code>name</code> as a new type name\nAllow Rust quoting identifiers (<code>#(ident)</code>) in the source\nParse operation builder definition\nCreate a builder for this lexer input\nClone the parsing data and return the cloned context\nGet the list of comments stored in this parse context\nObtain a reference to the context’s data\nObtain an exclusive reference to the context’s data\nDefault GLSL version number to parse source as\nExtract the subtree for Self from a parent tree R\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn <code>true</code> if this parsing context supports comments\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsume this ParseContext and return its data. Will fail …\nReturn <code>true</code> if the given name is a type name\nReturn <code>true</code> if the given name is a type name\nInstantiate the parser\nCreate new parsing options using default values\nCreate a new parsing context from this options object\nCreate a new ParseContextData object\nUpdate the context data with a new identifier in a given …\nUpdate the context data with a new identifier in a given …\nCreate a new parsing context from this options object, …\nCreate a new parsing context from this options object, …\nCreate a new parsing context from this options object and …\nCreate a new parsing context from this options object, …\nParse the input\nParse the input source\nParse the input source\nParse the input source\nParse the input source with the given context\nParse the input source with the given context\nParse the input source with the given context\nParse the input source with the given options\nParse the input source with the given options\nParse the input source with the given options\nLeave the current nesting level\nLeave the current nesting level\nEnter a new nesting level for declarations\nEnter a new nesting level for declarations\nUnique source identifier for token positions\n<code>true</code> if the GLSL target should be Vulkan instead of OpenGL\nCreate a new ParseContextData object with comments parsing …\nCreate a new ParseContextData object with comments parsing …\nCreate a new parse context cloning the given one’s data, …\nCreate a new ParseContextData object with the given type …\nWrap the given source which parses as Self into something …\nTrait for creating parse builders from lexer inputs\nType of the lexer associated with this input\nBuilder structure for a parsing operation\nCreate a builder for this lexer input\nSet the parse options for this parse\nCreate a new parse builder from the given input string\nExecute the parsing operation, and extract the wanted node\nCreate a new parse builder from the given input string\nSet the parse options for this parse\nExecute the parsing operation\nExecute the parsing operation\nSet the parser instance to use for this parse\nPart of the syntax tree that can be extracted from a …\nA parsable is something we can parse either directly, or …\nExtract the subtree for Self from a parent tree R\nParse the input source\nParse the input source with the given context\nParse the input source with the given options\nWrap the given source which parses as Self into something …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA GLSL450/GLSL460 transpiler that takes a syntax tree and …\nFormatting settings for the GLSL transpiler\nFormatting state of the GLSL transpiler\nPrecedence information for transpiling parentheses properly\nIndentation style of the output\nA newline\nNo indentation is generated\nNo whitespace\nA space\nItems are indented with spaces.\nItems are indented with tabs. In case spaces are needed …\nFormatter whitespace\nWhat to insert after the case label ending colon\nWhether to collapse compound statements that contain a …\nConsume the current function definition statement\nConsume the pending newlines\nWhat to insert after a declaration\nExit the current list initializer\nEnter a new block, and update the indentation level\nCommon logic for entering a new block, and updating the …\nEnter a case label\nEnter a collapsed compound statement\nEnter a new compound statement block, and update the …\nEnters a new external declaration, flushing pending …\nEnter a new function definition statement\nEnter a list initializer\nExit the current block, and update the indentation level\nExit the current collapsed compound statement\nExits the current external declaration\nFlush pending newlines to the output, if any\nFlush pending newlines as spaces to the output, if any\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nWhat to insert after a function definition\nIndentation style of the output\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMinifying (e.g, source code size reducing) formatting …\nMakes sure that the next text to be written to the output …\nAppend a pending new line to the output\nInsert newline after block close brace\nInsert newline after a compound statement collapsed to a …\nInsert newlines after block open braces\nInsert newlines before block close braces\nInsert newline after a compound statement collapsed to a …\nReturn the precedence level of the expression\nFormatting settings\nTranspile an array_spec to GLSL\nTranspile an arrayed_identifier to GLSL\nTranspile an assignment_op to GLSL\nTranspile a binary_op to GLSL\nTranspile a block(f: &amp;mut F, b: &amp;ast::Block, state: &amp;mut …\nTranspile a case_label to GLSL\nTranspile a compound_statement to GLSL\nTranspile a condition to GLSL\nTranspile a declaration to GLSL\nTranspile a double(f: &amp;mut F, x: f64, _: &amp;mut …\nTranspile an expr to GLSL\nTranspile an expression_statement to GLSL\nTranspile an external_declaration to GLSL\nTranspile a float(f: &amp;mut F, x: f32, _: &amp;mut …\nTranspile a for_init_statement to GLSL\nTranspile a for_rest_statement to GLSL\nTranspile a fully_specified_type to GLSL\nTranspile a function_definition to GLSL\nTranspile a function_identifier to GLSL\nTranspile a function_parameter_declaration to GLSL\nTranspile a function_parameter_declarator to GLSL\nTranspile a function_prototype to GLSL\nTranspile an identifier to GLSL\nTranspile an init_declarator_list to GLSL\nTranspile an initializer to GLSL\nTranspile an interpolation_qualifier to GLSL\nTranspile an iteration_statement to GLSL\nTranspile a jump_statement to GLSL\nTranspile a layout_qualifier to GLSL\nTranspile a layout_qualifier_spec to GLSL\nTranspile a path(f: &amp;mut F, path: &amp;ast::Path, _: &amp;mut …\nTranspile a precision_qualifier to GLSL\nTranspile a preprocessor to GLSL\nTranspile a preprocessor_define to GLSL\nTranspile a preprocessor_else(f: &amp;mut F, _: &amp;mut …\nTranspile a preprocessor_elseif to GLSL\nTranspile a preprocessor_endif(f: &amp;mut F, _: &amp;mut …\nTranspile a preprocessor_error to GLSL\nTranspile a preprocessor_extension to GLSL\nTranspile a preprocessor_if to GLSL\nTranspile a preprocessor_ifdef to GLSL\nTranspile a preprocessor_ifndef to GLSL\nTranspile a preprocessor_include to GLSL\nTranspile a preprocessor_line to GLSL\nTranspile a preprocessor_pragma to GLSL\nTranspile a preprocessor_undef to GLSL\nTranspile a preprocessor_version to GLSL\nTranspile a selection_rest_statement to GLSL\nTranspile a selection_statement to GLSL\nTranspile a single_declaration to GLSL\nTranspile a single_declaration_no_type to GLSL\nTranspile a statement to GLSL\nTranspile a storage_qualifier to GLSL\nTranspile a struct to GLSL\nTranspile a struct_field to GLSL\nTranspile a struct_non_declaration to GLSL\nTranspile a subroutine to GLSL\nTranspile a switch_statement to GLSL\nTranspile a translation_unit to GLSL\nTranspile a type_name to GLSL\nTranspile a type_qualifier to GLSL\nTranspile a type_qualifier_spec to GLSL\nTranspile a type_specifier to GLSL\nTranspile a type_specifier_non_array to GLSL\nTranspile an unary_op to GLSL\nInsert a space after a for statement separator token …\nInsert a space after a list separator token (i.e., comma)\nInsert a space before the else keyword in an if statement\nInsert a space before block open braces\nInsert spaces around binary ops\nInsert a space after the { and before the } delimiting a …\nInsert a space before the ( and after the ) that are part …\nWhat to insert after a statement\nWhat to insert after a struct declaration\nWhat to insert between fields of a struct\nWrite the current indenting level and style to the output\nWrite this whitespace to the output\nWrite a binary operator\nWrite a declaration terminator\nWrite a else keyword, part of an if statement\nWrite a for statement separator\nWrite a function definition terminator\nWrite a list separator\nWrite a closing parenthesis for a statement\nWrite an opening parenthesis for a statement\nWrite a statement terminator\nWrite a struct declaration terminator\nWrite a struct field separator\nNumber of tab characters used per indent level\nNumber of space characters used per indent level\nSize of the tabs in characters\nThe visitor will go deeper in the AST by visiting all the …\nPart of the AST that can be visited.\nPart of the AST that can be visited.\nThe visitor won’t visit children nor siblings and will …\nVisit strategy after having visited an AST node.\nVisitor object, visiting AST nodes.\nVisitor object, visiting AST nodes.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nVisit an AST node.\nVisit an AST node.")